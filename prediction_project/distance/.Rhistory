FBY[,,i] <- boot.res$FBY
#permute.res <- permute.tests(DATA=DATA, DESIGN = DESIGN, group.masses = group.masses, weights = weights, hellinger = hellinger, symmetric = symmetric, k = k)
permute.res <- permute.tests(DATA=DATA, DESIGN = DESIGN, group.masses = group.masses, weights = weights, symmetric = symmetric, k = k)
eigs.perm.matrix[i,] <- permute.res$perm.eigs
r2.perm[i,] <- permute.res$perm.r2
inertia.perm[i,] <- permute.res$perm.inertia
}
if(i == 1){ ##end the inference clock; begin the loo clock.
transition.time <- proc.time()
inf.cycle.time <- transition.time - inf.start.time
loo.start.time <- transition.time
}
if(i <= n.rows){
#loo.test.res <- loo.test(DATA=DATA, DESIGN = DESIGN, group.masses = group.masses, weights = weights, hellinger = hellinger, symmetric = symmetric, k = k, i)
loo.test.res <- loo.test(DATA=DATA, DESIGN = DESIGN, group.masses = group.masses, weights = weights, symmetric = symmetric, k = k, i)
loo.assign[i,] <- loo.test.res$assignSup$assignments
loo.fii[i,] <- loo.test.res$supX$fii
}
if(i == 1){ ##end the loo clock and interact with user.
loo.cycle.time <- proc.time() - loo.start.time
if(!continueResampling((inf.cycle.time [1] * test.iters) + (loo.cycle.time[1]*n.rows))){
##exit strategy.
return(fixed.res)
}
}
setTxtProgressBar(pb,i)
}
rownames(FBX) <- colnames(DATA)
rownames(FBY) <- colnames(DESIGN)
x.boot.tests <- boot.ratio.test(FBX,critical.value)
class(x.boot.tests) <- c("tinpoBootTests","list")
fj.boot.data <- list(tests=x.boot.tests,boots=FBX)
class(fj.boot.data) <- c("tinpoBoot","list")
y.boot.tests <- boot.ratio.test(FBY,critical.value)
class(y.boot.tests) <- c("tinpoBootTests","list")
fi.boot.data <- list(tests=y.boot.tests,boots=FBY)
class(fi.boot.data) <- c("tinpoBoot","list")
boot.data <- list(fj.boot.data=fj.boot.data,fi.boot.data=fi.boot.data)
class(boot.data) <- c("tinpoAllBoots","list")
eigs.perm.matrix <- round(eigs.perm.matrix,digits=15)
component.p.vals <- 1-(colSums(eigs.perm.matrix < matrix(fixed.res$TExPosition.Data$eigs,test.iters, ncomps,byrow=TRUE))/test.iters)
component.p.vals[which(component.p.vals==0)] <- 1/test.iters
components.data <- list(p.vals=round(component.p.vals,digits=4), eigs.perm=eigs.perm.matrix, eigs=fixed.res$TExPosition.Data$eigs)
class(components.data) <- c("tinpoComponents","list")
omni.p <- max(1-(sum(inertia.perm < sum(fixed.res$TExPosition.Data$eigs))/test.iters),1/test.iters)
omni.data <- list(p.val=round(omni.p,digits=4),inertia.perm=inertia.perm,inertia=sum(fixed.res$TExPosition.Data$eigs))
class(omni.data) <- c("tinpoOmni","list")
r2.p <- max(1-(sum(r2.perm < sum(fixed.res$TExPosition.Data$assign$r2))/test.iters),1/test.iters)
r2.data <- list(p.val=round(r2.p,digits=4),r2.perm=r2.perm,r2=fixed.res$TExPosition.Data$assign$r2)
class(r2.data) <- c("tinpoR2","list")
loo.confuse <- t(loo.assign) %*% DESIGN
rownames(loo.confuse) <- paste(colnames(DESIGN),"predicted",sep=".")
colnames(loo.confuse) <- paste(colnames(DESIGN),"actual",sep=".")
fixed.confuse <- fixed.res$TExPosition.Data$assign$confusion
loo.acc <- sum(diag(loo.confuse))/sum(loo.confuse)
fixed.acc <- sum(diag(fixed.confuse))/sum(fixed.confuse)
loo.data <- list(loo.assign=loo.assign, loo.fii=loo.fii, loo.confuse=loo.confuse, fixed.confuse=fixed.confuse, loo.acc=loo.acc, fixed.acc=fixed.acc)
class(loo.data) <- c("tinpoLOO","list")
Inference.Data <- list(omni=omni.data,r2=r2.data,components=components.data,boot.data=boot.data,loo.data=loo.data)
class(Inference.Data) <- c("tepDICA.inference.battery","list")
ret.data <- list(Fixed.Data=fixed.res,Inference.Data=Inference.Data)
class(ret.data) <- c("tinpoOutput","list")
if(graphs){
tinGraphs(ret.data)
}
return(ret.data)
}
plot.fs.alternative <- function(DESIGN, fs, eigs,
tau, d = 1, mode="CI",
method = " ", col_index = c("#66CDAA","#4682B4","#AB63FA","#FFA15A"), assign=assign_AD, NEW_DESIGN = new_design)
{
fs <- as.matrix(fs)
# GETMEANS
fm.tmp <- aggregate(fs, list(DESIGN), mean)
fm <- fm.tmp[,2:ncol(fm.tmp)]
rownames(fm) <- fm.tmp[,1]
tau <- round(tau)
color.dot <- as.matrix(DESIGN)
na.de <- as.matrix(levels(DESIGN))
num.de <- length(na.de)
index <- col_index
# index <- prettyGraphsColorSelection(n.colors = 4)
for (i in 1: num.de){
color.dot[which(color.dot == na.de[i])] <- index[i]
}
a_color.dot <- as.data.frame(color.dot)
color.dot2 <- as.data.frame(color.dot)
print(color.dot2)
for (i in 1:61){
# if rownames of color.dot belongs to assign_AD, then assign
if (as.numeric(rownames(a_color.dot)[i]) %in% assign[["caseid"]]){
color.dot2[i, 'V1'] <- index[4]
}
else {
color.dot2[i, 'V1'] <- "#808080"
}
}
color.dot <- as.matrix(color.dot)
rownames(color.dot) <- DESIGN
# color.dot2
color.dot2 <- as.matrix(color.dot2)
rownames(color.dot2) <- NEW_DESIGN
print(color.dot2)
fs.plot <- createFactorMap(fs, # data
title = paste0("Factor Scores_",
method),
alpha.points = 0.5,
axis1 = d, axis2 = (d+1),
pch = 19,
cex = 2,
text.cex = 2.5,
display.labels = TRUE,
col.points = color.dot2,
col.labels =  color.dot2
)
fs.label <- createxyLabels.gen(d,(d+1),
lambda = eigs,
tau = tau,
axisName = "Component "
)
ind <- c(1:num.de)
for (i in 1:num.de){
inde <- match(rownames(color.dot),
sort(rownames(fm)))
ind[i] <- which(inde == i)[1]
}
grp.ind <- ind
rownames(fm[sort(rownames(fm)),]) <- sub("[[:punct:]]","",
rownames(fm[sort(rownames(fm)),]))
graphs.means <- PTCA4CATA:: createFactorMap(fm[sort(rownames(fm)),],
axis1 = d, axis2 =(d+1),
constraints = fs.plot$constraints,
col.points = color.dot[grp.ind],
col.labels = color.dot[grp.ind],
alpha.points = 0.9)
BootCube <- PTCA4CATA::Boot4Mean(fs,
design = as.factor(DESIGN),
niter = 100)
dimnames(BootCube$BootCube)[[2]] <- paste0("dim ", 1:dim(BootCube$BootCube)[[2]])
boot.elli <- MakeCIEllipses(data =
BootCube$BootCube[,d:(d+1),][sort(rownames(BootCube$BootCube[,d:(d+1),])),,],
names.of.factors =
c(paste0("Dimension ", d),paste0("Dimension ",
(d+1))),
col = color.dot[grp.ind],
alpha.line = 0.3,
alpha.ellipse = 0.3
)
# with Hull
colnames(fs) <- paste0('Dimension ', 1:ncol(fs))
# getting the color correct: an ugly trick
#col.groups <- as.data.frame(col.groups)
DESIGN <- factor(DESIGN, levels = DESIGN[grp.ind])
GraphHull <- PTCA4CATA::MakeToleranceIntervals(fs,
axis1 = d,
axis2 = (d+1),
design = DESIGN,
col = color.dot[grp.ind],
names.of.factors =  c(paste0("Dim ", d),
paste0("Dim 2", (d+1))),
p.level = 1.00)
if (mode == "hull"){
factor.map <- fs.plot$zeMap_background +
GraphHull +
fs.plot$zeMap_dots +
fs.plot$zeMap_text +
fs.label +
graphs.means$zeMap_dots +
graphs.means$zeMap_text}
if (mode == "CI"){
factor.map <- fs.plot$zeMap_background +
boot.elli +
fs.plot$zeMap_dots +
fs.plot$zeMap_text +
fs.label +
graphs.means$zeMap_dots +
graphs.means$zeMap_text}
factor.map
}
# rename fii
rownames(res.DICA$TExPosition.Data$fii) <- bins.table$caseid
plot.fs.alternative(bins.table$group,
res.DICA$TExPosition.Data$fii,
res.DICA$TExPosition.Data$eigs,
res.DICA$TExPosition.Data$t,
d=1,
mode="CI",
method = "DICA", assign=assign_AD, NEW_DESIGN=new_design)
# This script is to conduct analyses for "Computational Markers of Alzheimer's Disease". The Analyses have several steps: 1. Clean Data; 2 Doing PCA for each block; 3. Compare results from MCA to PCA; 4. Bin the results; 5. MUDICA analyses
library(PTCA4CATA)
library(TExPosition)
library(TInPosition)
library(data4PCCAR)
library(ExPosition)
library(InPosition)
library(ggplot2)
library(readxl)
library(psych)
source("functions.R")
library(gridExtra)
library(ggplotify)
library(grid)
library(knitr)
# Read the dataset
file_path <- "/Users/yilewang/workspaces/data4project/prediction_project/prediction_data.xlsx"
table <- as.data.frame(read_excel(file_path, sheet = "main_K21", skip = 1))
# get only table$group == SNC and AD
# table <- table[table$group %in% c("SNC", "AD"),]
# reindex table
rownames(table) <- 1:nrow(table)
# groups definition
# levels(table$group) <- c("SNC","AD")
levels(table$group) <- c("SNC","NC","MCI","AD")
# manually setting color design
m.color.design <- as.matrix(colnames(table))
# Each block
ignition.table <- table[13:28]
m.color.design[13:28] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
tvb_para.table <- table[29:34]
m.color.design[29:34] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
# for regular main table
SimFreq.table <- table[35:48]
m.color.design[35:48] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
sc.table <- table[49:57]
m.color.design[49:57] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
wdc.table <- table[58:74]
m.color.design[58:74] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
# for main_spike_burst table
# SimFreq.table <- table[35:51]
# m.color.design[35:51] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
#
# sc.table <- table[52:60]
# m.color.design[52:60] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
#
# wdc.table <- table[61:77]
# m.color.design[61:77] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
##########################################
# the color of participants
ob.color.design <- as.matrix(rownames(table))
# ob.color.design[1:10] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
# ob.color.design[11:23] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
# ob.color.design <- as.matrix(rownames(table))
ob.color.design[1:10] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
ob.color.design[11:26] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
ob.color.design[27:61] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
ob.color.design[62:74] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
##########################################
end_col <- length(colnames(table))
start_col <- 13
hist.beforebin <- multi.hist(table[,start_col:end_col])
# Bins the data
bins.table <- as.data.frame(table)
for(i in start_col:end_col){
bins.table[,i] <- bins_helper(bins.table[,i],
colnames(bins.table)[i])
}
clear
# This script is to conduct analyses for "Computational Markers of Alzheimer's Disease". The Analyses have several steps: 1. Clean Data; 2 Doing PCA for each block; 3. Compare results from MCA to PCA; 4. Bin the results; 5. MUDICA analyses
library(PTCA4CATA)
library(TExPosition)
library(TInPosition)
library(data4PCCAR)
library(ExPosition)
library(InPosition)
library(ggplot2)
library(readxl)
library(psych)
source("functions.R")
library(gridExtra)
library(ggplotify)
library(grid)
library(knitr)
# Read the dataset
file_path <- "/Users/yilewang/workspaces/data4project/prediction_project/prediction_data.xlsx"
table <- as.data.frame(read_excel(file_path, sheet = "main_K21", skip = 1))
# get only table$group == SNC and AD
# table <- table[table$group %in% c("SNC", "AD"),]
# reindex table
rownames(table) <- 1:nrow(table)
# groups definition
# levels(table$group) <- c("SNC","AD")
levels(table$group) <- c("SNC","NC","MCI","AD")
# manually setting color design
m.color.design <- as.matrix(colnames(table))
# Each block
ignition.table <- table[13:28]
m.color.design[13:28] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
tvb_para.table <- table[29:34]
m.color.design[29:34] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
# for regular main table
SimFreq.table <- table[35:48]
m.color.design[35:48] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
sc.table <- table[49:57]
m.color.design[49:57] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
wdc.table <- table[58:74]
m.color.design[58:74] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
# for main_spike_burst table
# SimFreq.table <- table[35:51]
# m.color.design[35:51] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
#
# sc.table <- table[52:60]
# m.color.design[52:60] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
#
# wdc.table <- table[61:77]
# m.color.design[61:77] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
##########################################
# the color of participants
ob.color.design <- as.matrix(rownames(table))
# ob.color.design[1:10] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
# ob.color.design[11:23] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
# ob.color.design <- as.matrix(rownames(table))
ob.color.design[1:10] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
ob.color.design[11:26] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
ob.color.design[27:61] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
ob.color.design[62:74] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
##########################################
end_col <- length(colnames(table))
start_col <- 13
hist.beforebin <- multi.hist(table[,start_col:end_col])
# Bins the data
bins.table <- as.data.frame(table)
for(i in start_col:end_col){
bins.table[,i] <- bins_helper(bins.table[,i],
colnames(bins.table)[i])
}
View(bins.table)
# This script is to conduct analyses for "Computational Markers of Alzheimer's Disease". The Analyses have several steps: 1. Clean Data; 2 Doing PCA for each block; 3. Compare results from MCA to PCA; 4. Bin the results; 5. MUDICA analyses
library(PTCA4CATA)
library(TExPosition)
library(TInPosition)
library(data4PCCAR)
library(ExPosition)
library(InPosition)
library(ggplot2)
library(readxl)
library(psych)
source("functions.R")
library(gridExtra)
library(ggplotify)
library(grid)
library(knitr)
# Read the dataset
file_path <- "/Users/yilewang/workspaces/data4project/prediction_project/prediction_data.xlsx"
table <- as.data.frame(read_excel(file_path, sheet = "main_K21", skip = 1))
# get only table$group == SNC and AD
# table <- table[table$group %in% c("SNC", "AD"),]
# reindex table
rownames(table) <- 1:nrow(table)
# groups definition
# levels(table$group) <- c("SNC","AD")
levels(table$group) <- c("SNC","NC","MCI","AD")
# manually setting color design
m.color.design <- as.matrix(colnames(table))
# Each block
ignition.table <- table[13:28]
m.color.design[13:28] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
tvb_para.table <- table[29:34]
m.color.design[29:34] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
# for regular main table
SimFreq.table <- table[35:48]
m.color.design[35:48] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
sc.table <- table[49:57]
m.color.design[49:57] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
wdc.table <- table[58:74]
m.color.design[58:74] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
# for main_spike_burst table
# SimFreq.table <- table[35:51]
# m.color.design[35:51] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
#
# sc.table <- table[52:60]
# m.color.design[52:60] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
#
# wdc.table <- table[61:77]
# m.color.design[61:77] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
##########################################
# the color of participants
ob.color.design <- as.matrix(rownames(table))
# ob.color.design[1:10] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
# ob.color.design[11:23] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
# ob.color.design <- as.matrix(rownames(table))
ob.color.design[1:10] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
ob.color.design[11:26] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
ob.color.design[27:61] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
ob.color.design[62:74] <- prettyGraphsColorSelection(starting.color = sample(1:170, 1))
##########################################
end_col <- length(colnames(table))
start_col <- 13
hist.beforebin <- multi.hist(table[,start_col:end_col])
# Bins the data
bins.table <- as.data.frame(table)
for(i in start_col:end_col){
bins.table[,i] <- bins_helper(bins.table[,i],
colnames(bins.table)[i])
}
hist.afterbin <- multi.hist(bins.table[,start_col:end_col])
data.table <- SimFreq.table
# PCA
# res.PCA <- epPCA(DATA = data.table, center = TRUE,
#                  scale = 'SS1',
#                  DESIGN = table$group, graphs = FALSE)
#
# res.PCA.inf <- epPCA.inference.battery(DATA = data.table,
#                                        center = TRUE,
#                                        scale = 'SS1',
#                                        DESIGN = table$group,
#                                        graphs = FALSE)
#
# plot.scree(res.PCA$ExPosition.Data$eigs, res.PCA.inf$Inference.Data$components$p.vals)
# plot.permutation(res.PCA.inf$Inference.Data$components$eigs.perm, res.PCA$ExPosition.Data$eigs)
# Multiple Corresponding Analysis
# res.MCA <- epMCA(DATA = bins.table[13:end_col],
#                  DESIGN = table$group,
#                  graphs = FALSE)
# res.MCA.inf <- epMCA.inference.battery(DATA = bins.table[13:end_col],
#                                        DESIGN = table$group, graphs = FALSE)
# plot.scree(res.MCA$ExPosition.Data$eigs, res.MCA.inf$Inference.Data$components$p.vals)
# plot.permutation(res.MCA.inf$Inference.Data$components$eigs.perm, res.MCA$ExPosition.Data$eigs)
# DICA
g.masses <- NULL
# g.masses <-  rep(1 / ncol(makeNominalData(bins.table[13:end_col])), length(unique(descriptors$AgeGen)))
res.DICA <- tepDICA(bins.table[start_col:end_col], make_data_nominal = TRUE, symmetric = TRUE,
group.masses = g.masses,
#weight = rep(1, nrow(XYmat)),# -- if equal weights for all columns,
DESIGN = table$group, graphs = FALSE)
# Inferences ----
set.seed(70301) # set the seed
# For random effects model so that we all have the same results.
nIter = 1000
res.DICA.inf <- tepDICA.inference.battery(bins.table[start_col:end_col], make_data_nominal = TRUE, symmetric = TRUE,
DESIGN = table$group,
group.masses = g.masses,
test.iters = nIter,
#weight = rep(1, nrow(XYmat)), # -- if equal weights for all columns,
graphs = FALSE)
plot.scree(res.DICA$TExPosition.Data$eigs, res.DICA.inf$Inference.Data$components$p.vals)
plot.permutation(res.DICA.inf$Inference.Data$components$eigs.perm, res.DICA$TExPosition.Data$eigs)
# get levels of color
col4Levels <- data4PCCAR::coloringLevels(
rownames(res.DICA$TExPosition.Data$fj), m.color.design)
col4Labels <- col4Levels$color4Levels
### make correlation plot
# get some color
col4Levels <- data4PCCAR::coloringLevels(
rownames(res.DICA$TExPosition.Data$fj), m.color.design[start_col:end_col])
col4Labels <- col4Levels$color4Levels
# plot color
col <-colorRampPalette(c("#BB4444",
"#EE9988",
"#FFFFFF",
"#77AADD",
"#4477AA"))
corrMatBurt.list <- phi2Mat4BurtTable(bins.table[start_col:end_col])
# plot
corr4MCA.r <- corrplot::corrplot(
as.matrix(corrMatBurt.list$phi2.mat^(1/2)),
method="color",
col=col(200),
type="upper",
#addCoef.col = "black",
tl.col = m.color.design[start_col:end_col],
tl.cex = .7,
tl.srt = 60,#Text label color and rotation
#number.cex = .5,
#order = 'FPC',
diag = TRUE # needed to have the color of variables correct
)
# rename fii
rownames(res.DICA$TExPosition.Data$fii) <- bins.table$caseid
plot.fs(bins.table$group,
res.DICA$TExPosition.Data$fii,
res.DICA$TExPosition.Data$eigs,
res.DICA$TExPosition.Data$t,
d=1,
mode="CI",
method = "DICA")
plot.loading(bins.table[start_col:end_col],
col=m.color.design[start_col:end_col],
res.DICA$TExPosition.Data$fii, res.DICA$TExPosition.Data$eigs,
res.DICA$TExPosition.Data$t, d=1)
plot.cfs(res.DICA$TExPosition.Data$fj, res.DICA$TExPosition.Data$eigs, res.DICA$TExPosition.Data$t, d=1, col=col4Labels, method="DICA", colrow="row")
plot.cb(res.DICA$TExPosition.Data$cj,
res.DICA$TExPosition.Data$fj,
col = col4Labels,
boot.ratios=res.DICA.inf$Inference.Data$boot.data$fj.boot.data$tests$boot.ratios,
signifOnly = TRUE, fig = 3, horizontal = FALSE, colrow = "col", fontsize = 2,
d=1)
# Confusion Matrix
fixed.confusion <- res.DICA.inf$Inference.Data$loo.data$fixed.confuse
random.confusion <- res.DICA.inf$Inference.Data$loo.data$loo.confuse
fixed.acc <- res.DICA.inf$Inference.Data$loo.data$fixed.acc
random.acc <- res.DICA.inf$Inference.Data$loo.data$loo.acc
fixed.assign <- res.DICA.inf[["Fixed.Data"]][["TExPosition.Data"]][["assign"]][["assignments"]]
# rename
rownames(fixed.confusion) <- sub("[[:punct:]]","",
rownames(fixed.confusion))
rownames(random.confusion) <- sub("[[:punct:]]","",
rownames(random.confusion))
colnames(fixed.confusion)<- sub("[[:punct:]]","",
colnames(fixed.confusion))
colnames(random.confusion)<- sub("[[:punct:]]","",
colnames(random.confusion))
rownames(fixed.confusion) <- paste0(rownames(fixed.confusion),
".predicted")
colnames(fixed.confusion) <- paste0(colnames(fixed.confusion),
".actual")
# print table and accurarcy
kable(fixed.confusion,
caption = "Fixed Confustion Matrix")
rownames(fixed.assign) <- table$caseid
print(fixed.assign)
print(res.DICA$TExPosition.Data$cj)
print(res.DICA$TExPosition.Data$fj)
